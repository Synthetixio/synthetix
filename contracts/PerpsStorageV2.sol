pragma solidity ^0.5.16;
pragma experimental ABIEncoderV2;

import "./State.sol";

import "./interfaces/IPerpsInterfacesV2.sol";

/*
 Immutable storage contract for Perps V2 positions and market states.

 Write access is only by PerpsEngineV2 (which in turn is charge of correctly managing this state) -
 assigned by address by system owner (and not through address resolver).

 Contains mostly the minimal setters and getters and input validation.
*/
contract PerpsStorageV2 is IPerpsStorageV2External, IPerpsStorageV2Internal, IPerpsTypesV2, State {
    /* ========== EVENTS ========== */
    event MarketInitialised(bytes32 marketKey, bytes32 baseAsset);
    event PositionInitialised(bytes32 indexed marketKey, uint id, address account);
    event FundingUpdated(bytes32 indexed marketKey, int funding, uint timestamp);

    /* ========== PUBLIC STATE ========== */

    // storage is split between multiple variables instead of nesting in a single e.g. Market
    // struct so that at some getters are autogenerated and no state remains inaccessible

    /// market level aggregators that are scalars (singe value)
    mapping(bytes32 => MarketScalars) public marketScalars;
    // getter marketScalars(bytes32)(MarketScalars)

    /// last FundingEntry (funding accrued and update timestamp) structs for each market
    mapping(bytes32 => FundingEntry) public lastFundingEntry;
    // getter lastFundingEntry(bytes32)(FundingEntry)

    /// market => positionIds => account owners, translate id to account (accounts to id is help
    // as part or _positions (accessed via positions())
    mapping(bytes32 => mapping(uint => address)) public positionIdToAccount;
    // getter positionIdToAccount(bytes32, uint)(address)

    bytes32 public constant CONTRACT_NAME = "PerpsStorageV2";

    /* ========== INTERNAL STATE ========== */

    /// internal mapping of positions (internal in order to ensure marketKey on access is
    /// always consistent with call)
    mapping(bytes32 => mapping(address => Position)) internal _positions;

    /* ========== MODIFIERS ========== */

    /// ensure market is initialized
    modifier requireInit(bytes32 marketKey) {
        require(marketScalars[marketKey].baseAsset != bytes32(0), "Market not initialised");
        _;
    }

    /* ========== CONSTRUCTOR ========== */

    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}

    /* ========== EXTERNAL VIEWS ========== */

    /// Most views are autogenerated

    /// last stored position state for market and account
    /// ensures marketKey is set correctly even if position is not initialized
    /// because marketKey may be used in views using this result (even possibly before a position is stored)
    function position(bytes32 marketKey, address account) public view returns (Position memory _position) {
        _position = _positions[marketKey][account];
        // ensure returned position always has the right market key as requested
        // even if position or market are not initialized
        _position.marketKey = marketKey;
    }

    /* ========== EXTERNAL MUTATIVE ========== */

    /// Init market ONLY once, with non zero marketKey and baseAsset
    /// initialized baseAsset and funding start timestamp
    function initMarket(bytes32 marketKey, bytes32 baseAsset) external onlyAssociatedContract {
        // validate input
        require(marketKey != bytes32(0), "Market key cannot be empty");
        require(baseAsset != bytes32(0), "Asset key cannot be empty");
        // load market
        MarketScalars storage market = marketScalars[marketKey];
        // check is not initialized already (can only be initialized once)
        // (it should be ok to re-initialize if no positions were created yet, but
        // this would only be needed if baseAsset was incorrectly set the first time, so is
        // an edge case that doesn't justify any added side effects concerns for a less strict check)
        require(market.baseAsset == bytes32(0), "Already initialized");
        // set asset
        market.baseAsset = baseAsset;
        // event
        emit MarketInitialised(marketKey, baseAsset);
        // initialise the funding with 0 initially accrued
        updateFunding(marketKey, 0);
    }

    /// initialize or just get the initialized position
    /// intended for mutative methods that may create a new position
    /// Position init increments the markets position counter, updates position's id, last funding entry
    /// account, and update the reverse ids => accounts mapping
    function positionWithInit(bytes32 marketKey, address account)
        public
        onlyAssociatedContract
        requireInit(marketKey)
        returns (Position memory _position)
    {
        _position = position(marketKey, account);

        // if position has no id, it wasn't initialized, initialize it:
        if (_position.id == 0) {
            uint id = ++marketScalars[marketKey].lastPositionId; // increment position id and return

            // user positions start from 1 to avoid clashing with default empty position
            _position.id = id;

            // update funding entry according to current latest entry
            _position.lastFundingEntry = lastFundingEntry[marketKey];

            // update owner mapping
            positionIdToAccount[marketKey][id] = account;

            // store it
            _positions[marketKey][account] = _position;

            // event
            emit PositionInitialised(marketKey, id, account);
        }

        return _position;
    }

    /// updates the latest funding entry (stores with latest block timestamp)
    function updateFunding(bytes32 marketKey, int funding) public onlyAssociatedContract requireInit(marketKey) {
        lastFundingEntry[marketKey] = FundingEntry(funding, block.timestamp);
        emit FundingUpdated(marketKey, funding, block.timestamp);
    }

    /// updates the stored position with whatever data is passed in
    /// checks position was initialized previously correctly
    /// updates last funding entry to latest market entry
    function storePosition(
        bytes32 marketKey,
        address account,
        uint newMargin,
        uint newLocked,
        int newSize,
        uint price
    ) external onlyAssociatedContract requireInit(marketKey) returns (Position memory) {
        // load the storage
        Position storage _position = _positions[marketKey][account];
        // ensure is initialized
        require(_position.id != 0, "Position not initialized");
        // update values according to inputs
        _position.margin = newMargin;
        _position.lockedMargin = newLocked;
        _position.size = newSize;
        _position.lastPrice = price;
        // update funding entry to last entry
        _position.lastFundingEntry = lastFundingEntry[marketKey];
        return _position;
    }

    /// stores the market aggregate scalars passed in as is
    function storeMarketAggregates(
        bytes32 marketKey,
        uint marketSize,
        int marketSkew,
        int entryDebtCorrection
    ) external onlyAssociatedContract requireInit(marketKey) {
        MarketScalars storage market = marketScalars[marketKey];
        market.marketSize = marketSize;
        market.marketSkew = marketSkew;
        market.entryDebtCorrection = entryDebtCorrection;
    }
}
