const fs = require('fs');
const path = require('path');
const { gray } = require('chalk');
const { task } = require('hardhat/config');
const { globSync } = require('hardhat/internal/util/glob');
const uniq = require('lodash.uniq');

/**
 * Task for merging multiple gasReporterOuput.json files generated by eth-gas-reporter
 * This task is necessary when we want to generate different parts of the reports
 * parallelized on different jobs, then merge the results and upload it to codechecks.
 * Gas Report JSON file schema: https://github.com/cgewecke/eth-gas-reporter/blob/master/docs/gasReporterOutput.md
 */

task('test:merge-gas-reports', 'Merge several gasReporterOuput.json files into one')
	.addOptionalParam('output', 'Target file to save the merged report', 'gasReporterOutput.json')
	.addVariadicPositionalParam(
		'input',
		'A list of gasReporterOutput.json files generated by eth-gas-reporter. Files can be defined using glob patterns'
	)
	.setAction(async taskArguments => {
		const output = path.resolve(taskArguments.output);

		// Parse input files and calculate glob patterns
		const input = uniq(taskArguments.input.map(globSync).flat()).map(inputFile =>
			path.resolve(inputFile)
		);

		if (input.length === 0) {
			throw new Error(`No files found for the given input: ${taskArguments.input.join(' ')}`);
		}

		console.log(gray(`Merging ${input.length} input files:`));
		input.forEach(inputFile => {
			console.log(gray('  - ', inputFile));
		});

		console.log(gray('\nOutput: ', output));

		const result = {
			namespace: null,
			config: null,
			info: {
				methods: {},
				deployments: [],
				blockLimit: null,
			},
		};

		input.forEach(inputFile => {
			const report = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));

			if (!report.config) {
				throw new Error(`Missing "config" property on ${inputFile}`);
			}

			if (!result.config) result.config = report.config;

			if (!result.namespace) {
				result.namespace = report.namespace;
			}

			if (result.namespace !== report.namespace) {
				throw new Error('Cannot merge reports with different namespaces');
			}

			// Update config.gasPrice only if the newer one has a bigger number
			if (typeof report.config.gasPrice === 'number') {
				if (
					typeof result.config.gasPrice !== 'number' ||
					result.config.gasPrice < report.config.gasPrice
				) {
					result.config.gasPrice = report.config.gasPrice;
				}
			} else {
				result.config.gasPrice = report.config.gasPrice;
			}

			if (!report.info || typeof report.info.blockLimit !== 'number') {
				throw new Error(`Invalid "info" property on ${inputFile}`);
			}

			if (!result.info.blockLimit) {
				result.info.blockLimit = report.info.blockLimit;
			} else if (result.info.blockLimit !== report.info.blockLimit) {
				throw new Error('"info.blockLimit" should be the same on all reports');
			}

			if (!report.info.methods) {
				throw new Error(`Missing "info.methods" property on ${inputFile}`);
			}

			// Merge info.methods objects
			Object.entries(report.info.methods).forEach(([key, value]) => {
				if (!result.info.methods[key]) {
					result.info.methods[key] = value;
					return;
				}

				result.info.methods[key].gasData = [
					...result.info.methods[key].gasData,
					...report.info.methods[key].gasData,
				].sort((a, b) => a - b);

				result.info.methods[key].numberOfCalls += report.info.methods[key].numberOfCalls;
			});

			if (!Array.isArray(report.info.deployments)) {
				throw new Error(`Invalid "info.deployments" property on ${inputFile}`);
			}

			// Merge info.deployments objects
			report.info.deployments.forEach(deployment => {
				const current = result.info.deployments.find(d => d.name === deployment.name);

				if (current) {
					current.gasData = [...current.gasData, ...deployment.gasData].sort((a, b) => a - b);
				} else {
					result.info.deployments.push(deployment);
				}
			});
		});

		fs.writeFileSync(output, JSON.stringify(result), 'utf-8');
	});
